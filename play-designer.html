<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Play Designer - Multi-Step</title>
    <style>
        :root { --primary: #1a237e; --accent: #ff6f00; --bg: #f0f2f5; --court: #e0bb86; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); margin: 0; display: flex; flex-direction: column; height: 100vh; }
        
        .toolbar-container { background: white; padding: 5px; border-bottom: 1px solid #ccc; display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; align-items: center; }
        .tool-group { display: flex; gap: 2px; border-right: 1px solid #ddd; padding-right: 5px; margin-right: 5px; align-items: center;}
        
        .tool-btn { padding: 6px 10px; background: #f0f0f0; border: 1px solid #ccc; cursor: pointer; border-radius: 4px; font-size: 0.9rem; display:flex; align-items:center; gap:5px;}
        .tool-btn:hover { background: #e0e0e0; }
        .tool-btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        .tool-btn.danger { background: #ffebee; color: #c62828; }
        
        /* Step Counter Style */
        .step-display { font-weight: bold; min-width: 60px; text-align: center; font-variant-numeric: tabular-nums; }

        select { padding: 6px; border-radius: 4px; border: 1px solid #ccc; }

        #main-area { flex: 1; display: flex; overflow: hidden; position: relative;}
        
        #canvas-container { flex: 1; background: #333; display: flex; justify-content: center; align-items: center; overflow: auto; position: relative; }
        #court-wrapper { position: relative; width: 800px; height: 600px; background: var(--court); border: 2px solid white; transition: height 0.3s; }
        canvas { position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
        
        /* Objects */
        .obj { position: absolute; width: 30px; height: 30px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; color: white; border: 2px solid white; cursor: grab; user-select: none; z-index: 20; box-shadow: 0 2px 5px rgba(0,0,0,0.5); font-size: 0.9rem;}
        .obj.atk { background: var(--primary); }
        .obj.def { background: #c62828; }
        .obj.ball { background: orange; border-color: black; color: black; font-size: 1.2rem; }
        .obj.cone { background: transparent; border: none; font-size: 1.8rem; box-shadow: none; }
        .obj.screen { background: transparent; border: none; box-shadow: none; border-radius: 0; width: 40px; height: 30px; }
        .obj.screen::after { content: "T"; font-weight: 900; font-size: 40px; color: #555; }
        .obj.label { background: transparent; border: none; color: black; width: auto; height: auto; font-size: 1rem; text-shadow: 0 0 2px white; box-shadow: none; white-space: nowrap;}

        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; justify-content: center; align-items: center; }
        .input-box { background: white; padding: 20px; border-radius: 8px; display: flex; gap: 10px; }
        
        @media print {
            .toolbar-container { display: none; }
            #canvas-container { background: white; }
            #court-wrapper { border: 1px solid black; }
        }
    </style>
</head>
<body>

    <div class="toolbar-container">
        <div class="tool-group">
            <button class="tool-btn" onclick="addObj('atk')">üë§ Atk</button>
            <button class="tool-btn" onclick="addObj('def')">üõ°Ô∏è Def</button>
            <button class="tool-btn" onclick="addObj('ball')">üèÄ Ball</button>
            <button class="tool-btn" onclick="addObj('cone')">‚ö†Ô∏è Cone</button>
            <button class="tool-btn" onclick="addObj('screen')">T Screen</button>
            <button class="tool-btn" onclick="promptLabel()">Aa Label</button>
        </div>
        
        <div class="tool-group">
            <button class="tool-btn active" onclick="setTool('move')">‚úã Move</button>
            <button class="tool-btn" onclick="setTool('cut')">‚ûù Cut</button>
            <button class="tool-btn" onclick="setTool('dribble')">„Ä∞ Dribble</button>
            <button class="tool-btn" onclick="setTool('pass')">--- Pass</button>
            <button class="tool-btn danger" onclick="setTool('eraser')">‚å´ Eraser</button>
        </div>

        <div class="tool-group" style="background: #e8f5e9;">
            <button class="tool-btn" title="Previous Step" onclick="changeStep(-1)">‚óÄ</button>
            <span id="step-count" class="step-display">Step 1/1</span>
            <button class="tool-btn" title="Next Step" onclick="changeStep(1)">‚ñ∂</button>
            <button class="tool-btn" onclick="addStep()" title="Add New Step">‚ûï Add</button>
            <button class="tool-btn danger" onclick="deleteStep()" title="Delete Current Step">‚úï</button>
            <button id="play-btn" class="tool-btn" onclick="togglePlay()">‚èØ Play</button>
        </div>

        <div class="tool-group">
            <button class="tool-btn" onclick="toggleCourt()">üîÑ Half/Full</button>
            <select id="formation-select" onchange="loadFormation(this.value)">
                <option value="">-- Formations --</option>
                <option value="man">Man-to-Man</option>
                <option value="2-3">2-3 Zone</option>
                <option value="3-2">3-2 Zone</option>
                <option value="5-out">5 Out</option>
                <option value="4-1">4 Out 1 In</option>
            </select>
            <select id="quick-play-select" onchange="loadFormation(this.value)">
                <option value="">-- Quick Plays --</option>
                <option value="horns">Horns Set</option>
                <option value="box">Box Set</option>
            </select>
        </div>

        <div class="tool-group" style="border:none">
            <button class="tool-btn danger" onclick="clearFrame()">üóë Clear</button>
            <button class="tool-btn" onclick="exportPlay()">üíæ Save</button>
            <button class="tool-btn" onclick="document.getElementById('file-in').click()">üìÇ Load</button>
            <button class="tool-btn" onclick="window.print()">üñ® Print</button>
            <input type="file" id="file-in" style="display:none" onchange="loadPlay(this)">
        </div>
    </div>

    <div id="main-area">
        <div id="canvas-container">
            <div id="court-wrapper">
                <canvas id="court-canvas" width="800" height="600"></canvas>
            </div>
        </div>
    </div>
    
    <div id="label-modal" class="modal-overlay">
        <div class="input-box">
            <input type="text" id="label-text" placeholder="Enter Label Text">
            <button onclick="addLabel()">Add</button>
            <button onclick="document.getElementById('label-modal').style.display='none'">Cancel</button>
        </div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playClick() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(600, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            osc.start(); osc.stop(audioCtx.currentTime + 0.05);
        }

        const wrapper = document.getElementById('court-wrapper');
        const canvas = document.getElementById('court-canvas');
        const ctx = canvas.getContext('2d');
        
        // --- STATE MANAGEMENT ---
        let tool = 'move';
        let isDrawing = false;
        let isFullCourt = false;
        let startX, startY;
        
        // Multi-step State
        let steps = [{ objects: [], lines: [] }];
        let currentStepIndex = 0;
        let isPlaying = false;
        let playInterval = null;

        // Getters for convenience
        function getCurrObjects() { return steps[currentStepIndex].objects; }
        function getCurrLines() { return steps[currentStepIndex].lines; }

        // --- PRESETS ---
        const FORMATIONS = {
            'man':  [{type:'atk',label:'1',x:400,y:150}, {type:'atk',label:'2',x:150,y:400}, {type:'atk',label:'3',x:650,y:400}, {type:'atk',label:'4',x:250,y:400}, {type:'atk',label:'5',x:550,y:400}],
            '2-3':  [{type:'def',label:'X1',x:300,y:180}, {type:'def',label:'X2',x:500,y:180}, {type:'def',label:'X3',x:150,y:400}, {type:'def',label:'X4',x:400,y:400}, {type:'def',label:'X5',x:650,y:400}],
            '3-2':  [{type:'def',label:'X1',x:400,y:150}, {type:'def',label:'X2',x:200,y:200}, {type:'def',label:'X3',x:600,y:200}, {type:'def',label:'X4',x:300,y:400}, {type:'def',label:'X5',x:500,y:400}],
            '5-out':[{type:'atk',label:'1',x:400,y:100}, {type:'atk',label:'2',x:100,y:250}, {type:'atk',label:'3',x:700,y:250}, {type:'atk',label:'4',x:50,y:500}, {type:'atk',label:'5',x:750,y:500}],
            '4-1':  [{type:'atk',label:'1',x:400,y:100}, {type:'atk',label:'2',x:150,y:200}, {type:'atk',label:'3',x:650,y:200}, {type:'atk',label:'4',x:200,y:400}, {type:'atk',label:'5',x:450,y:300}],
            'horns':[{type:'atk',label:'1',x:400,y:150}, {type:'atk',label:'4',x:320,y:220}, {type:'atk',label:'5',x:480,y:220}, {type:'atk',label:'2',x:50,y:500}, {type:'atk',label:'3',x:750,y:500}],
            'box':  [{type:'atk',label:'1',x:400,y:150}, {type:'atk',label:'4',x:300,y:300}, {type:'atk',label:'5',x:500,y:300}, {type:'atk',label:'2',x:300,y:450}, {type:'atk',label:'3',x:500,y:450}]
        };

        function updateStepUI() {
            document.getElementById('step-count').innerText = `Step ${currentStepIndex + 1}/${steps.length}`;
            drawCourt();
            renderObjects();
        }

        // --- STEP LOGIC ---
        function addStep() {
            playClick();
            // Clone current objects, but clear lines for new movement
            const currentObjs = JSON.parse(JSON.stringify(getCurrObjects()));
            
            // Insert new step after current
            steps.splice(currentStepIndex + 1, 0, { objects: currentObjs, lines: [] });
            currentStepIndex++;
            updateStepUI();
        }

        function deleteStep() {
            if (steps.length <= 1) {
                alert("Cannot delete the only step.");
                return;
            }
            if (!confirm("Delete this step?")) return;
            playClick();
            steps.splice(currentStepIndex, 1);
            if (currentStepIndex >= steps.length) currentStepIndex = steps.length - 1;
            updateStepUI();
        }

        function changeStep(dir) {
            playClick();
            const newIndex = currentStepIndex + dir;
            if (newIndex >= 0 && newIndex < steps.length) {
                currentStepIndex = newIndex;
                updateStepUI();
            }
        }

        function togglePlay() {
            const btn = document.getElementById('play-btn');
            if (isPlaying) {
                clearInterval(playInterval);
                isPlaying = false;
                btn.innerText = "‚èØ Play";
                btn.classList.remove('active');
            } else {
                isPlaying = true;
                btn.innerText = "‚èπ Stop";
                btn.classList.add('active');
                playInterval = setInterval(() => {
                    currentStepIndex++;
                    if (currentStepIndex >= steps.length) currentStepIndex = 0;
                    updateStepUI();
                }, 1500); // 1.5 seconds per step
            }
        }

        // --- RENDERING ---

        function drawCourt() {
            ctx.clearRect(0,0, canvas.width, canvas.height);
            const W = 800; 
            const H = isFullCourt ? 1000 : 600;
            const lines = getCurrLines();

            // Draw Lines
            lines.forEach(l => {
                ctx.beginPath();
                ctx.strokeStyle = l.style === 'pass' ? 'black' : (l.style === 'dribble' ? 'blue' : '#333');
                ctx.lineWidth = 3;
                if(l.style === 'dribble') ctx.setLineDash([10, 5]); 
                else if(l.style === 'pass') ctx.setLineDash([2, 5]); 
                else ctx.setLineDash([]); 

                const headlen = 10; const dx = l.x2 - l.x1; const dy = l.y2 - l.y1; const angle = Math.atan2(dy, dx);
                ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
                
                // Arrowhead
                ctx.beginPath(); ctx.setLineDash([]); ctx.moveTo(l.x2, l.y2);
                ctx.lineTo(l.x2 - headlen * Math.cos(angle - Math.PI / 6), l.y2 - headlen * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(l.x2 - headlen * Math.cos(angle + Math.PI / 6), l.y2 - headlen * Math.sin(angle + Math.PI / 6));
                ctx.lineTo(l.x2, l.y2); ctx.fillStyle = ctx.strokeStyle; ctx.fill();
            });

            // Court markings
            ctx.strokeStyle = "rgba(255,255,255,0.7)"; ctx.lineWidth = 4; ctx.setLineDash([]);
            ctx.strokeRect(20, 20, W-40, H-40);

            if(!isFullCourt) {
                ctx.beginPath(); ctx.arc(W/2, 300, 60, 0, Math.PI*2); ctx.stroke(); 
                ctx.beginPath(); ctx.moveTo(W/2 - 250, 20); ctx.lineTo(W/2 - 250, 190); ctx.stroke(); 
                ctx.beginPath(); ctx.moveTo(W/2 + 250, 20); ctx.lineTo(W/2 + 250, 190); ctx.stroke(); 
                ctx.strokeRect(W/2 - 80, 20, 160, 190); 
                ctx.beginPath(); ctx.arc(W/2, 120, 250, 0, Math.PI, false); ctx.stroke(); 
                ctx.beginPath(); ctx.arc(W/2, 40, 10, 0, Math.PI*2); ctx.lineWidth=2; ctx.stroke();
            } else {
                ctx.beginPath(); ctx.moveTo(20, H/2); ctx.lineTo(W-20, H/2); ctx.stroke(); 
                ctx.beginPath(); ctx.arc(W/2, H/2, 50, 0, Math.PI*2); ctx.stroke(); 
                ctx.strokeRect(W/2 - 80, 20, 160, 190);
                ctx.beginPath(); ctx.arc(W/2, 120, 250, 0, Math.PI, false); ctx.stroke();
                ctx.strokeRect(W/2 - 80, H-210, 160, 190);
                ctx.beginPath(); ctx.arc(W/2, H-120, 250, Math.PI, 0, false); ctx.stroke();
            }
        }

        function renderObjects() {
            document.querySelectorAll('.obj').forEach(e => e.remove());
            const objects = getCurrObjects();

            objects.forEach((obj, idx) => {
                const el = document.createElement('div');
                el.className = `obj ${obj.type}`;
                
                if(obj.type === 'cone') el.innerText = '‚ö†Ô∏è';
                else if(obj.type === 'screen') el.innerText = '';
                else el.innerText = obj.label;

                el.style.left = obj.x + 'px'; el.style.top = obj.y + 'px';
                
                // Delete Object
                el.onclick = function() { 
                    if(tool === 'eraser') { 
                        playClick(); 
                        getCurrObjects().splice(idx, 1); 
                        renderObjects(); 
                    } 
                }
                
                // Drag Logic
                el.onmousedown = function(e) {
                    if(tool !== 'move') return;
                    e.preventDefault();
                    let shiftX = e.clientX - el.getBoundingClientRect().left;
                    let shiftY = e.clientY - el.getBoundingClientRect().top;
                    
                    const moveAt = (px, py) => { 
                        obj.x = px - shiftX - wrapper.getBoundingClientRect().left; 
                        obj.y = py - shiftY - wrapper.getBoundingClientRect().top; 
                        el.style.left = obj.x + 'px'; 
                        el.style.top = obj.y + 'px'; 
                    };
                    const onMove = (e) => moveAt(e.clientX, e.clientY);
                    
                    document.addEventListener('mousemove', onMove);
                    el.onmouseup = function() { 
                        document.removeEventListener('mousemove', onMove); 
                        el.onmouseup = null; 
                    };
                };
                wrapper.appendChild(el);
            });
        }

        // --- INTERACTION ---

        wrapper.onmousedown = function(e) {
            if(tool === 'move') return;
            const rect = wrapper.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Eraser: Lines
            if(tool === 'eraser') {
                const lines = getCurrLines();
                const initialLen = lines.length;
                const newLines = lines.filter(l => {
                    const dist = Math.abs((l.y2-l.y1)*clickX - (l.x2-l.x1)*clickY + l.x2*l.y1 - l.y2*l.x1) / Math.sqrt(Math.pow(l.y2-l.y1,2) + Math.pow(l.x2-l.x1,2));
                    return dist > 10; 
                });
                
                // We must update the array in place or reassign
                steps[currentStepIndex].lines = newLines;

                if(newLines.length < initialLen) playClick();
                drawCourt();
                return;
            }
            
            // Start Drawing
            startX = clickX; startY = clickY; isDrawing = true;
        };

        wrapper.onmouseup = function(e) {
            if(!isDrawing) return;
            const rect = wrapper.getBoundingClientRect();
            getCurrLines().push({x1: startX, y1: startY, x2: e.clientX - rect.left, y2: e.clientY - rect.top, style: tool});
            isDrawing = false; drawCourt(); playClick();
        };

        function setTool(t) {
            playClick();
            tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            // Reactivate Play button if active? No, tools are separate.
            // But we need to highlight the tool button
            // Finding the specific button that triggered this is tricky if called programmatically, 
            // so we rely on the click event target if available.
            if(event && event.target && event.target.tagName === 'BUTTON') {
                event.target.classList.add('active');
            }
            wrapper.style.cursor = t === 'move' ? 'default' : (t === 'eraser' ? 'crosshair' : 'crosshair');
        }

        function addObj(type) {
            playClick();
            let label = '';
            const objects = getCurrObjects();
            if(type === 'atk') label = prompt("Player Number?", (objects.filter(o=>o.type=='atk').length+1));
            if(type === 'def') label = prompt("Defender Label?", "X" + (objects.filter(o=>o.type=='def').length+1));
            if((type === 'atk' || type === 'def') && !label) return;
            if(type === 'ball') label = 'üèÄ';
            
            objects.push({id: Date.now(), type, x: 400, y: 300, label: label || ''});
            renderObjects();
        }

        function promptLabel() { document.getElementById('label-modal').style.display = 'flex'; }
        
        function addLabel() {
            const txt = document.getElementById('label-text').value;
            if(txt) getCurrObjects().push({id: Date.now(), type:'label', x: 400, y: 300, label: txt});
            document.getElementById('label-modal').style.display = 'none'; renderObjects(); playClick();
        }

        function toggleCourt() {
            playClick();
            isFullCourt = !isFullCourt;
            wrapper.style.height = isFullCourt ? '1000px' : '600px';
            canvas.height = isFullCourt ? 1000 : 600;
            drawCourt();
        }

        function loadFormation(key) {
            if(!key) return;
            if(confirm("Replace current step with formation?")) {
                clearFrame();
                if(FORMATIONS[key]) {
                    steps[currentStepIndex].objects = JSON.parse(JSON.stringify(FORMATIONS[key]));
                    renderObjects();
                }
            }
            document.getElementById('formation-select').value = "";
            document.getElementById('quick-play-select').value = "";
        }

        function clearFrame() { 
            playClick(); 
            steps[currentStepIndex].objects = []; 
            steps[currentStepIndex].lines = []; 
            renderObjects(); 
            drawCourt(); 
        }

        // --- FILE OPS ---

        function exportPlay() {
            // Save all steps
            const data = JSON.stringify({ steps, isFullCourt, version: 2 });
            const blob = new Blob([data], {type: 'application/json'});
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'Play_MultiStep.json'; a.click();
        }
        
        function loadPlay(input) {
            const file = input.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = JSON.parse(e.target.result);
                
                // Handle V2 (Multi-step)
                if (data.version === 2 || data.steps) {
                    steps = data.steps;
                    currentStepIndex = 0;
                } 
                // Handle V1 (Single step legacy)
                else if (data.objects) {
                    steps = [{ objects: data.objects, lines: data.lines || [] }];
                    currentStepIndex = 0;
                }
                
                isFullCourt = !!data.isFullCourt;
                if(isFullCourt && wrapper.style.height !== '1000px') toggleCourt(); 
                if(!isFullCourt && wrapper.style.height === '1000px') toggleCourt();
                
                updateStepUI();
            };
            reader.readAsText(file);
        }

        drawCourt();
    </script>
</body>
</html>